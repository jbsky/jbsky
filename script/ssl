#!/bin/bash
#================================================================
# HEADER
#================================================================
#% SYNOPSIS
#+    ${SCRIPT_NAME} {OPTIONS}
#+
#% DESCRIPTION
#% Script helping to generate and manage SSL certificates.
#%
#% /!\Don't forget to put the following lines in /etc/default/openssl
#%
#% OPTIONS
#%    -a                                                create authority
#%    -m                                                show cert
#%    -s                                                create cert server
#%    -r                                                revoke cert
#%    -c                                                create cert client
#%    -h                                                print this help
#%    -v                                                verbose
#%
#%
#================================================================
#- IMPLEMENTATION
#-    version         ${SCRIPT_NAME} 0.0.1
#-    author        Jbsky
#-    copyright
#-    license         GNU General Public License
#-
#================================================================
#  HISTORY
#     2016/03/01 : Script creation
#
#================================================================
#  DEBUG OPTION
# set -n  # Uncomment to check your syntax, without execution.
# set -x  # Uncomment to debug this shell script
#
#================================================================
# END_OF_HEADER
#================================================================

WK_DIR="/etc/ssl"
KEY_DIR="${HOME}/.keys"

#============================
#  FUNCTIONS
#============================

CheckAndCreateFolder(){

    if [ ! -d ${1} ];then
        mkdir -p ${1}
        chgrp ssl-cert ${1}
    else
        echo "${SCRIPT_NAME}: Config folder created ${1}" 1>&2
    fi
}

#============================
#  Renseigne les variables passees par defaut du sujet dans OpenSSL
DoDefault(){
    [ ${flagOptVerbose} -eq 1 ] &&     echo "DoDefault"

    cat >/etc/default/ssl << EOF
email=mail@super.fr
bits=8192
days=365
O=MySuperOrg
L=
ST=
C=FR
OU=
oscp=
EOF

}

PrintMinimalConf(){
printf "

[ req ]
distinguished_name = req_distinguished_name

[ req_distinguished_name ]

[ v3_req ]
basicConstraints = CA:FALSE
keyUsage = digitalSignature, keyEncipherment
extendedKeyUsage = serverAuth, clientAuth

[ v3_ca ]
subjectKeyIdentifier=hash
authorityKeyIdentifier=keyid:always,issuer
basicConstraints = critical,CA:true
keyUsage = cRLSign, keyCertSign

[ policy_match ]
countryName             = match
stateOrProvinceName     = match
organizationName        = match
organizationalUnitName  = optional
commonName              = supplied
emailAddress            = optional



[ tmp_ca ]
dir             = $dir
certs           = \$dir/certs
crl_dir         = \$dir/crl
database        = \$dir/index.txt
new_certs_dir   = \$dir/newcerts
certificate     = \$dir/cacert.pem
serial          = \$dir/serial
crlnumber       = \$dir/crlnumber
crl             = \$dir/crl.pem
private_key     = \$dir/private/cakey.pem
RANDFILE        = \$dir/private/.rand
x509_extensions = usr_cert
name_opt        = ca_default
cert_opt        = ca_default
default_days    = 365
default_crl_days= 30
default_md      = default               # use public key default MD
preserve        = no                    # keep passed DN ordering
policy          = policy_match

# Ajout de la partie suivante pour signer un certif d'autorite enfant
[ ca ]
default_ca      = tmp_ca
"


}
PrintCAConf(){
printf "

[ ca_ext ]
keyUsage = critical,keyCertSign,cRLSign
basicConstraints = critical,CA:true
subjectKeyIdentifier = hash
authorityKeyIdentifier = keyid:always
"
}
PrintCertConf(){
printf "
[cert]
subjectKeyIdentifier              = hash
authorityKeyIdentifier            = keyid,issuer:always
issuerAltName                     = issuer:copy
basicConstraints                  = critical,CA:FALSE
keyUsage                          = digitalSignature, nonRepudiation, keyEncipherment
nsCertType                        = ${nsCertType}
extendedKeyUsage                  = ${extendedKeyUsage}
nsComment                         = \"OpenSSL Generated Certificate\"
"
if [ "${flagOptServeur}" = "1" ];then
printf "subjectAltName                    = @alt_names

[alt_names]
${alt_names}
"
fi
}

CreerAutorite(){

    [ ${flagOptVerbose} -eq 1 ]&& echo "CreerAutorite"

    if [ ! -f  ${dir}/cacert.pem ];then

        [ -d  ${dir} ] && echo "${SCRIPT_NAME}: Folder ${dir} already exit " 1>&2

        CheckAndCreateFolder ${dir}/certs
        CheckAndCreateFolder ${dir}/crl
        CheckAndCreateFolder ${dir}/newcerts
        CheckAndCreateFolder ${dir}/private
        chmod -R 350 ${dir}/private
        if [ ! -f ${dir}/index.txt ];then
            touch ${dir}/index.txt
        else
            echo "${SCRIPT_NAME}: ${1}/index.txt already exit " 1>&2
        fi
        if [ ! -f ${dir}/serial ];then
            touch ${dir}/serial
        else
            echo "${SCRIPT_NAME}: ${1}/serial already exit " 1>&2
        fi
        [ "${C}" = "" ] ||subj="/C=${C}"
        [ "${ST}" = "" ]||subj="${subj}/ST=${ST}"
        [ "${L}" = "" ] ||subj="${subj}/L=${L}"
        [ "${O}" = "" ] ||subj="${subj}/O=${O}"
        [ "${OU}" = "" ]||subj="${subj}/OU=Secure Digital Certificate Signing"
        subj="${subj}/CN=${OptAutorite} - Certification Authority Root"

        if [ -f ${dir}/private/ca.key ];then
            echo "${dir}/private/cat.key already exist, continu..." 1>&2
        else
            RANDPASS=$(date | md5sum |  cut -c1-16)
            touch ${KEY_DIR}/${OptAutorite}.key
            echo "$RANDPASS" >  ${KEY_DIR}/${OptAutorite}.key
            openssl genrsa -out ${dir}/private/cakey.pem -passout file:${KEY_DIR}/${OptAutorite}.key ${bits}
        fi


        # Soit le certificat Racine n'a pas de parent
        if [ $flagOptParent -eq 1 ];then
            # Soit le certificat a un parent / intermediaire
            echo "Demande de CSR..."
            openssl req -new -out ${WK_DIR}/${OptAutorite}/CA.csr -key ${WK_DIR}/${OptAutorite}/private/cakey.pem -subj "${subj}" -config <(PrintMinimalConf)
            # On switch sur la conf parent
            dir=${WK_DIR}/${OptParent}

            #& La certif parent signe avec sa clé
            echo "On signe"

            openssl ca -batch -days ${days} -create_serial -passin file:${KEY_DIR}/${OptParent}.key -in ${WK_DIR}/${OptAutorite}/CA.csr -out ${WK_DIR}/${OptAutorite}/cacert.pem -extensions ca_ext -notext -config <(PrintMinimalConf;PrintCAConf)
            mv ${WK_DIR}/${OptAutorite}/cacert.pem ${WK_DIR}/${OptAutorite}/cacert.pem.backup

            cat ${WK_DIR}/${OptAutorite}/cacert.pem.backup ${dir}/cacert.pem > ${WK_DIR}/${OptAutorite}/cacert.pem


            # On switch sur la nouvelle autorite
            dir=${WK_DIR}/${OptAutorite}
        else
            # Soit le certificat est bien racine / pas de parent
            openssl req -x509 -sha512 -extensions v3_ca -days ${days} -subj "${subj}" -key ${dir}/private/cakey.pem -out ${dir}/cacert.pem -config <(PrintMinimalConf)
        fi

        chgrp ssl-cert ${dir}/private/cakey.pem
        chgrp ssl-cert ${dir}/cacert.pem
        chmod 400 ${dir}/private/cakey.pem
        chmod 444 ${dir}/cacert.pem
        openssl x509 -serial -noout -in ${dir}/cacert.pem | cut -d= -f2 > ${dir}/serial
        printf "%X\n" $((0x`cat ${dir}/serial`+1))>${dir}/serial

    else
        echo "${dir}/cacert.pem already exist, continu..." 1>&2
    fi
}

RevokeCertificat(){
echo dir: $dir
openssl ca -revoke ${dir}/certs/${OptRevokeCert}.pem -name tmp_ca -passin file:${KEYFILE}  -config <(PrintMinimalConf)

mv ${dir}/certs/${OptRevokeCert}.pem  ${dir}/certs/${OptRevokeCert}.pem.${DATE}.drop
mv ${dir}/private/${OptRevokeCert}.key  ${dir}/private/${OptRevokeCert}.key.${DATE}.drop
}

CreerCertificat(){
    nsCertType=""
    if [ "${flagOptClient}" = "1" ];then
        nsCertType="client, email, objsign"
        extendedKeyUsage="clientAuth"
    fi
    if [ "${flagOptServeur}" = "1" ];then
        if [[ "${nsCertType}" == "" ]];then
            nsCertType="server"
            extendedKeyUsage="serverAuth"

        else
            nsCertType="client, server"
            extendedKeyUsage="serverAuth, clientAuth"
        fi
    fi
    index=0
    CommonName=" "
    [ "${C}" = "" ] ||subj="/C=${C}"
    [ "${ST}" = "" ]||subj="${subj}/ST=${ST}"
    [ "${L}" = "" ] ||subj="${subj}/L=${L}"
    [ "${O}" = "" ] ||subj="${subj}/O=${O}"
    [ "${OU}" = "" ]||subj="${subj}/OU=${OU}"
    [ "${emailAddress}" = "" ]||subj="${subj}/emailAddress=${emailAddress}"
    if [ "${OptCN}" != "" ]; then
        OLDIFS=$IFS
        IFS=';'

        read -ra field <<< $OptCN
        for CommonName in "${field[@]}";
        do
            if [[ "${firstCN}" == ""  ]];then
            # alt_names="DNS.${index}:${CommonName}"
                firstCN=${CommonName}
                index=$((${index}+1))
                alt_names="DNS.${index}=${CommonName}"
            else
                index=$((${index}+1))
                alt_names="${alt_names}\nDNS.${index}=${CommonName}"
            fi
        done
        IFS=$OLDIFS
        CommonName=""
    fi

    while [ "${CommonName}" != "" ];do
        read -p "CN ${index}:" CommonName
        if [[ "${CommonName}" != "" && "${firstCN}" == ""  ]];then
            firstCN=${CommonName}
            index=$((${index}+1))
            alt_names="DNS.${index}=${CommonName}"
        else
            if [[ "${CommonName}" != "" ]];then
                index=$((${index}+1))
                alt_names="${alt_names}\nDNS.${index}=${CommonName}"
            fi
        fi
    done

    subj="${subj}/CN=${firstCN}"
    firstCN=${firstCN/\*/\\\*}

    [ ${flagOptVerbose} -eq 1 ]&& echo "CreerCertificat"

    if [ -f ${dir}/private/${firstCN}.key ];then
        echo "${dir}/private/${firstCN}.key already exist, continu..." 1>&2
    else
        openssl genrsa  -out ${dir}/private/${firstCN}.key ${bits}
    fi

    if [ ! -f ${dir}/certs/${firstCN}.pem ];then

        if [ ${flagOptVerbose} -eq 1 ];then
            echo "openssl req -new -sha256 -key ${dir}/private/${firstCN}.key -out ${dir}/newcerts/${firstCN}.csr -nodes -subj "${subj}" -config <(";PrintMinimalConf;echo ")"
        fi
        openssl req -new -sha256 -key ${dir}/private/${firstCN}.key -out ${dir}/newcerts/${firstCN}.csr -nodes -subj "${subj}" -config  <(PrintMinimalConf)

        if [ ${flagOptVerbose} -eq 1 ];then
            echo "openssl ca -name tmp_ca -batch -passin file:${KEYFILE} -extensions cert -in ${dir}/newcerts/${firstCN}.csr -out ${dir}/certs/${firstCN}.pem -config <(";PrintMinimalConf;PrintCertConf; echo ")"
        fi
        openssl ca -name tmp_ca -batch -passin file:${KEYFILE} -extensions cert -in ${dir}/newcerts/${firstCN}.csr -out ${dir}/certs/${firstCN}.pem -config <(PrintMinimalConf;PrintCertConf)

        RANDPASS=$(date | md5sum |  cut -c1-8)

        if [ ${flagOptVerbose} -eq 1 ];then
            echo "openssl pkcs12 -export -password pass:$RANDPASS -inkey ${dir}/private/${firstCN}.key -in ${dir}/certs/${firstCN}.pem -name "${firstCN}" -certfile ${dir}/cacert.pem -caname "${ca}" -out ${dir}/${firstCN}.p12"
        fi
        openssl pkcs12 -export -password pass:$RANDPASS -inkey ${dir}/private/${firstCN}.key -in ${dir}/certs/${firstCN}.pem -name "${firstCN}" -certfile ${dir}/cacert.pem -caname "${ca}" -out ${dir}/${firstCN}.p12

        echo "password : $RANDPASS"
        echo $RANDPASS >  ${dir}/${firstCN}.passwd
        chmod 400 ${dir}/private/${firstCN}.key
        chmod 444 ${dir}/certs/${firstCN}.pem
        chgrp ssl-cert ${dir}/certs/${firstCN}.pem
        chgrp ssl-cert ${dir}/private/${firstCN}.key
    else
        echo "${dir}/certs/${firstCN}.pem already exist, continu..." 1>&2
    fi
}

#============================
#  FUNCTIONS
#============================

#== usage function ==#
usage() {
    . /etc/default/ssl;
    printf "Usage: ";
    head -${SCRIPT_HEADSIZE:-99} ${0} | grep -e "^#+" | sed -e "s/^#+[ ]*//g" -e "s/\${SCRIPT_NAME}/${SCRIPT_NAME}/g";

}

usagefull() {
    . /etc/default/ssl;
    head -${SCRIPT_HEADSIZE:-99} ${0} | grep -e "^#[%+-]" | sed -e "s/^#[%+-]//g" -e "s/\${SCRIPT_NAME}/${SCRIPT_NAME}/g";
}
scriptinfo() { head -${SCRIPT_HEADSIZE:-99} ${0} | grep -e "^#-" | sed -e "s/^#-//g" -e "s/\${SCRIPT_NAME}/${SCRIPT_NAME}/g"; }


#============================
#  FILES AND VARIABLES
#============================

  #== general variables ==#
SCRIPT_HEADSIZE=$(head -200 ${0} |grep -n "^# END_OF_HEADER" | cut -f1 -d:)
SCRIPT_ID="$(scriptinfo | grep script_id | tr -s ' ' | cut -d' ' -f3)"
SCRIPT_NAME="$(basename ${0})" # scriptname without path
SCRIPT_UNIQ="${SCRIPT_NAME%.*}.${SCRIPT_ID}.$(date "+%y%m%d%H%M%S").${$}"
SCRIPT_DIR="$( cd $(dirname "$0") && pwd )" # script directory
SCRIPT_DIR_TEMP="/tmp" # Make sure temporary folder is RW

SCRIPT_TIMELOG_FLAG=0
SCRIPT_TIMELOG_FORMAT="+%y/%m/%d@%H:%M:%S"

HOSTNAME="$(hostname)"
FULL_COMMAND="${0} $*"
DATE=$(date +"%Y%m%d")
EXEC_DATE=$(date "+%y%m%d%H%M%S")
EXEC_ID=${$}


  #== option variables ==#
flagOptErr=0
flagOptLog=0
flagOptinfo=0
flagOptVerbose=0

  #== option variables pour appel de fonction ==#
flagOptAutorite=0
flagOptDefault=0
flagOptServeur=0
flagOptClient=0
flagOptPath=0

  #== options par d‚faut du script ==#
flagOptMenu=1;
flagOptDir=0
flagOptParent=0;

# typeset -A SSL_FLD
SSL_FLD=(
    RootAuthority
    Organisation
    Country
    Locality
    stateOrProvince
    emailAddress
    OCSP
    days
)

#============================
#  PARSE OPTIONS WITH GETOPTS
#============================

  #== set short options ==#
SCRIPT_OPTS='hvsr:ca:-:m:p:'

  #== set long options associated with short one ==#
typeset -A ARRAY_OPTS
ARRAY_OPTS=(
    [help]=h
    [montre]=m
    [verbose]=v
    [revoke]=r
    [server]=s
    [client]=c
    [authority]=a
    [parent]=p
    [info]=i
)

  #== parse options ==#
while getopts ${SCRIPT_OPTS} OPTION ; do
    if [[ "x$OPTION" == "x-" ]]; then
        LONG_OPTION=$OPTARG
        LONG_OPTARG=$(echo $LONG_OPTION | grep "=" | cut -d'=' -f2)
        LONG_OPTIND=-1
        [[ "x$LONG_OPTARG" = "x" ]] && LONG_OPTIND=$OPTIND || LONG_OPTION=$(echo $OPTARG | cut -d'=' -f1)
        [[ $LONG_OPTIND -ne -1 ]] && eval LONG_OPTARG="\$$LONG_OPTIND"
        OPTION=${ARRAY_OPTS[$LONG_OPTION]}
        [[ "x$OPTION" = "x" ]] &&  OPTION="?" OPTARG="-$LONG_OPTION"

        if [[ $( echo "${SCRIPT_OPTS}" | grep -c "${OPTION}:" ) -eq 1 ]]; then
            if [[ "x${LONG_OPTARG}" = "x" ]] || [[ "${LONG_OPTARG}" = -* ]]; then
                OPTION=":" OPTARG="-$LONG_OPTION"
            else
                OPTARG="$LONG_OPTARG";
                if [[ $LONG_OPTIND -ne -1 ]]; then
                    [[ $OPTIND -le $Optnum ]] && OPTIND=$(( $OPTIND+1 ))
                    shift $OPTIND
                    OPTIND=1
                fi
            fi
        fi
    fi

    #== options follow by another option instead of argument ==#
    if [[ "x${OPTION}" != "x:" ]] && [[ "x${OPTION}" != "x?" ]] && [[ "${OPTARG}" = -* ]]; then
        OPTARG="$OPTION" OPTION=":"
    fi
    #== manage options ==#
getopts_get_optional_argument() {
  eval next_token=\${$OPTIND}
  if [[ -n $next_token && $next_token != -* ]]; then
    OPTIND=$((OPTIND + 1))
    OPTARG=$next_token
  else
    OPTARG=""
  fi
}
    case "$OPTION" in
        a ) flagOptMenu=0;flagOptAutorite=1;OptAutorite="${OPTARG}";;

        p ) flagOptMenu=0;flagOptParent=1;OptParent="${OPTARG}";;

        r ) flagOptMenu=0;flagOptRevoke=1;OptRevokeCert="${OPTARG}";;

        s ) flagOptMenu=0;
        getopts_get_optional_argument $@
        OptCN="${OPTARG}";
        flagOptServeur=1;;

        c ) flagOptMenu=0;
        getopts_get_optional_argument $@
        OptCN=${OPTARG}
        echo $OptCN
        flagOptClient=1;;

        m)  flagOptMenu=0;flagOptMontre=1
            OptCert="${OPTARG}";;

        h ) usagefull
            exit 0;;

        i ) scriptinfo
            exit 0;;

        v ) flagOptVerbose=1
            set -x;;

        : ) echo "${SCRIPT_NAME}: -$OPTARG: option requires an argument"
            flagOptErr=1 ;;

        ? ) echo "${SCRIPT_NAME}: -$OPTARG: unknown option"
            flagOptErr=1 ;;
    esac
done
shift $((${OPTIND} - 1)) ## shift options

#============================
#  MAIN SCRIPT
#============================
if [ $flagOptMenu -eq 1 ];then
    usagefull
    exit 0
fi
if [ ! -f /etc/default/ssl ];then

    DoDefault
fi

. /etc/default/ssl

if [ $flagOptAutorite -eq 1 ];then
    dir="${WK_DIR}/$OptAutorite"
    KEYFILE="${KEY_DIR}/$OptAutorite.key"
else
    dir="${WK_DIR}/${O,,}"
    KEYFILE="${KEY_DIR}/${O,,}.key"

fi

if [ "${flagOptAutorite}" = "1" ];then

    if [ "${O,,}" != "$optAutorite" ] && [ ! -d ${dir} ];then
        echo "Nouveau repertoire de travail : $dir"
        read p
        CreerAutorite
    else
        if [ "${flagOptClient}" = "1" ];then
            [[ -r $KEYFILE ]] && CreerCertificat
            [[ -r $KEYFILE ]] || echo $KEYFILE not readable 1>&2 && exit 1;
        else
            if [ "${flagOptServeur}" = "1" ];then
                [[ -r $KEYFILE ]] && CreerCertificat
                [[ -r $KEYFILE ]] || echo $KEYFILE not readable 1>&2 && exit 1;
            else
                if [ "${flagOptRevoke}" = "1" ];then
                    [[ -r $KEYFILE ]] && RevokeCertificat
                    [[ -r $KEYFILE ]] || echo $KEYFILE not readable 1>&2 && exit 1;
                else
                    if [ "${flagOptMontre}" = "1" ];then
                        openssl x509 -in ${dir}/certs/${OptCert}.pem -noout -text
                    fi
                fi
            fi
        fi
    fi
else
    echo No flag autority specified, exit... 1>&2 && exit 2;
fi
