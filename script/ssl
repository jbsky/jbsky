#!/bin/bash
#================================================================
# HEADER
#================================================================
#% SYNOPSIS
#+    ${SCRIPT_NAME} {OPTIONS}
#+
#% DESCRIPTION
#% Script helping to generate and manage SSL certificates.
#%
#% /!\Don't forget to put the following lines in /etc/default/openssl
#%
#% OPTIONS
#%    -a                                                create authority
#%    -m                                                show cert
#%    -s                                                create cert server
#%    -r                                                revoke cert
#%    -c                                                create cert client
#%    -h                                                print this help
#%    -v                                                verbose
#%
#%
#================================================================
#- IMPLEMENTATION
#-    version         ${SCRIPT_NAME} 0.0.1
#-    author        Jbsky
#-    copyright
#-    license         GNU General Public License
#-
#================================================================
#  HISTORY
#     2016/03/01 : Script creation
#
#================================================================
#  DEBUG OPTION
# set -n  # Uncomment to check your syntax, without execution.
# set -x  # Uncomment to debug this shell script
#
#================================================================
# END_OF_HEADER
#================================================================

#============================
#  FUNCTIONS
#============================

CheckAndCreateFolder(){

    if [ ! -d ${1} ];then
        mkdir -p ${1} 
    else
        echo "${SCRIPT_NAME}: Config folder created ${1}" 1>&2
    fi
}

CheckAndCreateTreeFolder(){
    [ -d  ${1} ] && echo "${SCRIPT_NAME}: Folder ${1} already exit " 1>&2

    CheckAndCreateFolder ${1}/certs
    CheckAndCreateFolder ${1}/crl
    CheckAndCreateFolder ${1}/newcerts
    CheckAndCreateFolder ${1}/private
    chmod -R 600 ${1}/private
    if [ ! -f ${1}/index.txt ];then
        touch ${1}/index.txt
    else
        echo "${SCRIPT_NAME}: ${1}/index.txt already exit " 1>&2
    fi
    if [ ! -f ${1}/serial ];then
        touch ${1}/serial
    else
        echo "${SCRIPT_NAME}: ${1}/serial already exit " 1>&2
    fi
}

  #== renseigne le fichier /etc/default/ssl ==#
  #
DoDefault(){
    [ ${flagOptVerbose} -eq 1 ] &&     echo "DoDefault"

    cat >>/etc/default/ssl << EOF
email=webmaster@jbsky.fr
bits=8192
days=365
O=myOrg
L=
ST=
C=FR
OU=
oscp=
configfile=/etc/ssl/openssl.cnf
dir=/etc/ssl/${O,,}
KEYFILE=/root/ca.key
EOF

}


  #== cr‚er le fichier ${RootConfigFolder}/${RootConfigFile} ==#
  #== cr‚er CA Root ==#
CreerAutorite(){

    [ ${flagOptVerbose} -eq 1 ]&& echo "CreerAutorite"
    echo "Dans la partie [CA_default] du fichier /etc/ssl/openssl.cnf, on vérifie que le repertoire dir correspond à la variable dans /etc/default/ssl"
    read p
    if [ ! -f  ${dir}/cacert.pem ];then

        CheckAndCreateTreeFolder ${dir}

        [ "${C}" = "" ] ||subj="/C=${C}"
        [ "${ST}" = "" ]||subj="${subj}/ST=${ST}"
        [ "${L}" = "" ] ||subj="${subj}/L=${L}"
        [ "${O}" = "" ] ||subj="${subj}/O=${O}"
        [ "${OU}" = "" ]||subj="${subj}/OU=${OU}"
        subj="${subj}/CN=Secure Digital Certificate Signing"

        openssl req -x509 -newkey rsa:${bits} -sha512 -extensions v3_ca -days ${days} -config ${configfile} -subj "${subj}" -keyout ${dir}/private/cakey.pem -out ${dir}/cacert.pem 

        chmod 400 ${dir}/private/cakey.pem
        chmod 444 ${dir}/cacert.pem
        openssl x509 -serial -noout -in ${dir}/cacert.pem | cut -d= -f2 > ${dir}/serial
        printf "%X\n" $((0x`cat ${dir}/serial`+1))>${dir}/serial
    else
        echo "${dir}/cacert.pem already exist, continu..." 1>&2
    fi
}

RevokeCertificat(){
echo dir: $dir
openssl ca -revoke ${dir}/certs/${OptRevokeCert}.pem -name tmp_ca -passin file:${KEYFILE}  -config <(cat ${configfile} <(printf "

[tmp_ca]
dir             = $dir
certs           = \$dir/certs
crl_dir         = \$dir/crl
database        = \$dir/index.txt
new_certs_dir   = \$dir/newcerts
certificate     = \$dir/cacert.pem
serial          = \$dir/serial
crlnumber       = \$dir/crlnumber
crl             = \$dir/crl.pem
private_key     = \$dir/private/cakey.pem
RANDFILE        = \$dir/private/.rand
x509_extensions = usr_cert
name_opt        = ca_default
cert_opt        = ca_default
default_days    = 365
default_crl_days= 30
default_md      = default               # use public key default MD
preserve        = no                    # keep passed DN ordering
policy          = policy_match"))
mv ${dir}/certs/${OptRevokeCert}.pem  ${dir}/certs/${OptRevokeCert}.pem.${DATE}.drop
mv ${dir}/private/${OptRevokeCert}.key  ${dir}/private/${OptRevokeCert}.key.${DATE}.drop
}

CreerCertificat(){
    index=0
    CommonName=" "
    [ "${C}" = "" ] ||subj="/C=${C}"
    [ "${ST}" = "" ]||subj="${subj}/ST=${ST}"
    [ "${L}" = "" ] ||subj="${subj}/L=${L}"
    [ "${O}" = "" ] ||subj="${subj}/O=${O}"
    [ "${OU}" = "" ]||subj="${subj}/OU=${OU}"
    [ "${emailAddress}" = "" ]||subj="${subj}/emailAddress=${emailAddress}"
    if [ "${OptCN}" != "" ]; then
        OLDIFS=$IFS
        IFS=';'

        read -ra field <<< $OptCN
        for CommonName in "${field[@]}";
        do
            if [[ "${firstCN}" == ""  ]];then
            # alt_names="DNS.${index}:${CommonName}"
                firstCN=${CommonName}
                index=$((${index}+1))
                alt_names="DNS.${index}=${CommonName}"
            else
                index=$((${index}+1))
                alt_names="${alt_names}\nDNS.${index}=${CommonName}"
            fi
        done
        IFS=$OLDIFS
        CommonName=""
    fi

    while [ "${CommonName}" != "" ];do
        read -p "CN ${index}:" CommonName
        if [[ "${CommonName}" != "" && "${firstCN}" == ""  ]];then
            # alt_names="DNS.${index}:${CommonName}"
            firstCN=${CommonName}
            index=$((${index}+1))
            alt_names="DNS.${index}=${CommonName}"
        else
            if [[ "${CommonName}" != "" ]];then
                index=$((${index}+1))
                alt_names="${alt_names}\nDNS.${index}=${CommonName}"
            fi
        fi
    done
    subj="${subj}/CN=${firstCN}"
    # echo -e ${alt_names}
    firstCN=${firstCN/\*/\\\*}

    [ ${flagOptVerbose} -eq 1 ]&& echo "CreerCertificat"

    if [ -f ${dir}/private/${firstCN}.key ];then
        echo "${dir}/private/${firstCN}.key already exist, continu..." 1>&2
    else
#    -des3
        openssl genrsa  -out ${dir}/private/${firstCN}.key ${bits}
    fi

    if [ ! -f ${dir}/certs/${firstCN}.pem ];then

        if [ "${flagOptClient}" = "1" ];then
            [ ${flagOptVerbose} -eq 1 ] && echo "openssl req -new -sha256 -key ${dir}/private/${firstCN}.key -out ${dir}/newcerts/${firstCN}.csr -nodes -subj "${subj}" -config ${configfile}"

            openssl req -new -sha256 -key ${dir}/private/${firstCN}.key -out ${dir}/newcerts/${firstCN}.csr -nodes -subj "${subj}" -config  <(cat ${configfile} <(printf "
[client]
subjectKeyIdentifier              = hash
authorityKeyIdentifier            = keyid,issuer:always
subjectAltName                    = email:copy
issuerAltName                     = issuer:copy
basicConstraints                  = critical,CA:FALSE
keyUsage                          = digitalSignature, nonRepudiation, keyEncipherment
nsCertType                        = client, email, objsign
extendedKeyUsage                  = clientAuth
nsComment                         = \"OpenSSL Generated Certificate\"
"))
            [ ${flagOptVerbose} -eq 1 ] && echo " openssl ca -name tmp_ca -batch -passin file:${KEYFILE} -extensions client -in ${dir}/newcerts/${firstCN}.csr -out ${dir}/certs/${firstCN}.pem -config ${configfile}"

            openssl ca -name tmp_ca -batch -passin file:${KEYFILE} -extensions client -in ${dir}/newcerts/${firstCN}.csr -out ${dir}/certs/${firstCN}.pem -config <(cat ${configfile} <(printf "

[tmp_ca]
dir             = $dir
certs           = \$dir/certs
crl_dir         = \$dir/crl
database        = \$dir/index.txt
new_certs_dir   = \$dir/newcerts
certificate     = \$dir/cacert.pem
serial          = \$dir/serial
crlnumber       = \$dir/crlnumber
crl             = \$dir/crl.pem
private_key     = \$dir/private/cakey.pem
RANDFILE        = \$dir/private/.rand
x509_extensions = usr_cert
name_opt        = ca_default
cert_opt        = ca_default
default_days    = 365
default_crl_days= 30
default_md      = default               # use public key default MD
preserve        = no                    # keep passed DN ordering
policy          = policy_match

[client]
subjectKeyIdentifier              = hash
authorityKeyIdentifier            = keyid,issuer:always
subjectAltName                    = email:copy
issuerAltName                     = issuer:copy
basicConstraints                  = critical,CA:FALSE
keyUsage                          = digitalSignature, nonRepudiation, keyEncipherment
nsCertType                        = client, email, objsign
extendedKeyUsage                  = clientAuth
nsComment                         = \"OpenSSL Generated Certificate\"
"))

            RANDPASS=$(date | md5sum |  cut -c1-8)

            openssl pkcs12 -export -password pass:$RANDPASS -inkey ${dir}/private/${firstCN}.key -in ${dir}/certs/${firstCN}.pem -name "${firstCN}" -certfile ${dir}/cacert.pem -caname "${ca}" -out ${dir}/${firstCN}.p12
            echo "password : $RANDPASS"
            echo $RANDPASS >  ${dir}/${firstCN}.passwd
        fi
        if [ "${flagOptServeur}" = "1" ];then
            [ ${flagOptVerbose} -eq 1 ] && echo "openssl req -new -sha256 -key ${dir}/private/${firstCN}.key -out ${dir}/newcerts/${firstCN}.csr -nodes -subj "${subj}" -config  ${ConfigFile}"
            openssl req -new -sha256 -key ${dir}/private/${firstCN}.key -out ${dir}/newcerts/${firstCN}.csr -nodes -subj "${subj}" -config  <(cat ${configfile} <(printf "\n[alt_names]\n${alt_names}\n[server]
subjectKeyIdentifier              = hash
authorityKeyIdentifier            = keyid,issuer:always
issuerAltName                     = issuer:copy
subjectAltName                    = @alt_names
basicConstraints                  = critical,CA:FALSE
keyUsage                          = digitalSignature, nonRepudiation, keyEncipherment
nsCertType                        = server
extendedKeyUsage                  = serverAuth
nsComment                         = \"OpenSSL Generated Certificate\"
"))
            [ ${flagOptVerbose} -eq 1 ] && echo "openssl ca -name tmp_ca -batch -passin file:${KEYFILE} -extensions server -in ${dir}/newcerts/${firstCN}.csr -out ${dir}/certs/${firstCN}.pem  -config  ${ConfigFile}"
            openssl ca -name tmp_ca -batch -passin file:${KEYFILE} -extensions server -in ${dir}/newcerts/${firstCN}.csr -out ${dir}/certs/${firstCN}.pem  -config  <(cat ${configfile} <(printf "\n[alt_names]\n${alt_names}\n
[tmp_ca]
dir             = $dir
certs           = \$dir/certs
crl_dir         = \$dir/crl
database        = \$dir/index.txt
new_certs_dir   = \$dir/newcerts
certificate     = \$dir/cacert.pem
serial          = \$dir/serial
crlnumber       = \$dir/crlnumber
crl             = \$dir/crl.pem
private_key     = \$dir/private/cakey.pem
RANDFILE        = \$dir/private/.rand
x509_extensions = usr_cert
name_opt        = ca_default
cert_opt        = ca_default
default_days    = 365
default_crl_days= 30
default_md      = default               # use public key default MD
preserve        = no                    # keep passed DN ordering
policy          = policy_match


[server]
subjectKeyIdentifier              = hash
authorityKeyIdentifier            = keyid,issuer:always
issuerAltName                     = issuer:copy
subjectAltName                    = @alt_names
basicConstraints                  = critical,CA:FALSE
keyUsage                          = digitalSignature, nonRepudiation, keyEncipherment
nsCertType                        = server
extendedKeyUsage                  = serverAuth
nsComment                         = \"OpenSSL Generated Certificate\"
"))

        fi
        chmod 400 ${dir}/private/${firstCN}.key
        chmod 444 ${dir}/certs/${firstCN}.pem
    else
        echo "${dir}/certs/${firstCN}.pem already exist, continu..." 1>&2
    fi
}

#============================
#  FUNCTIONS
#============================

#== usage function ==#
usage() {
    . /etc/default/ssl;
    printf "Usage: ";
    head -${SCRIPT_HEADSIZE:-99} ${0} | grep -e "^#+" | sed -e "s/^#+[ ]*//g" -e "s/\${SCRIPT_NAME}/${SCRIPT_NAME}/g" | sed -e "s#\${DefaultConfigFile}#${DefaultConfigFile}#g";

}

usagefull() {
    . /etc/default/ssl;
    head -${SCRIPT_HEADSIZE:-99} ${0} | grep -e "^#[%+-]" | sed -e "s/^#[%+-]//g" -e "s/\${SCRIPT_NAME}/${SCRIPT_NAME}/g" | sed -e "s#\${DefaultConfigFile}#${DefaultConfigFile}#g";
}
scriptinfo() { head -${SCRIPT_HEADSIZE:-99} ${0} | grep -e "^#-" | sed -e "s/^#-//g" -e "s/\${SCRIPT_NAME}/${SCRIPT_NAME}/g"; }


#============================
#  FILES AND VARIABLES
#============================

  #== general variables ==#
SCRIPT_HEADSIZE=$(head -200 ${0} |grep -n "^# END_OF_HEADER" | cut -f1 -d:)
SCRIPT_ID="$(scriptinfo | grep script_id | tr -s ' ' | cut -d' ' -f3)"
SCRIPT_NAME="$(basename ${0})" # scriptname without path
SCRIPT_UNIQ="${SCRIPT_NAME%.*}.${SCRIPT_ID}.$(date "+%y%m%d%H%M%S").${$}"
SCRIPT_DIR="$( cd $(dirname "$0") && pwd )" # script directory
SCRIPT_DIR_TEMP="/tmp" # Make sure temporary folder is RW

SCRIPT_TIMELOG_FLAG=0
SCRIPT_TIMELOG_FORMAT="+%y/%m/%d@%H:%M:%S"

HOSTNAME="$(hostname)"
FULL_COMMAND="${0} $*"
DATE=$(date +"%Y%m%d")
EXEC_DATE=$(date "+%y%m%d%H%M%S")
EXEC_ID=${$}


  #== option variables ==#
flagOptErr=0
flagOptLog=0
flagOptinfo=0
flagOptVerbose=0

  #== option variables pour appel de fonction ==#
flagOptDefault=0
flagOptServeur=0
flagOptClient=0
flagOptRoot=0
flagOptIntermediate=0
flagOptPath=0

  #== options par d‚faut du script ==#
flagOptMenu=1;
DefaultConfigFile=""                     # label pour une sous certification … racine root
PathIntermediateConfigFile=""            # label pour une sous certification … racine root
IntermediateConfigFolder=""              # designe le r‚pertoire des certificat: $ConfigFolder/$IntermediateConfigFile
ConfigPathIConfigFile=""                 # designe le r‚pertoire des certificat: $ConfigFolder/$IntermediateConfigFile
ConfigFile=""                            # default: openssl.cnf
ConfigFolder=""                          # default: /etc/ssl/
RootConfigFile=""                        # ex: openssl.cnf
RootConfigFolder=""                      # ex: /etc/ssl/Root
RootAuthority=""                         # ex: Root

# typeset -A SSL_FLD
SSL_FLD=(
    RootAuthority
    Organisation
    Country
    Locality
    stateOrProvince
    emailAddress
    OCSP
    days
)

#============================
#  PARSE OPTIONS WITH GETOPTS
#============================

  #== set short options ==#
SCRIPT_OPTS='hvsr:ca:i:-:m:'

  #== set long options associated with short one ==#
typeset -A ARRAY_OPTS
ARRAY_OPTS=(
    [help]=h
    [montre]=m
    [verbose]=v
    [revoke]=r
    [server]=s
    [client]=c
    [authority]=a
    [intermediate]=i
    [info]=j
)

  #== parse options ==#
while getopts ${SCRIPT_OPTS} OPTION ; do
    if [[ "x$OPTION" == "x-" ]]; then
        LONG_OPTION=$OPTARG
        LONG_OPTARG=$(echo $LONG_OPTION | grep "=" | cut -d'=' -f2)
        LONG_OPTIND=-1
        [[ "x$LONG_OPTARG" = "x" ]] && LONG_OPTIND=$OPTIND || LONG_OPTION=$(echo $OPTARG | cut -d'=' -f1)
        [[ $LONG_OPTIND -ne -1 ]] && eval LONG_OPTARG="\$$LONG_OPTIND"
        OPTION=${ARRAY_OPTS[$LONG_OPTION]}
        [[ "x$OPTION" = "x" ]] &&  OPTION="?" OPTARG="-$LONG_OPTION"

        if [[ $( echo "${SCRIPT_OPTS}" | grep -c "${OPTION}:" ) -eq 1 ]]; then
            if [[ "x${LONG_OPTARG}" = "x" ]] || [[ "${LONG_OPTARG}" = -* ]]; then
                OPTION=":" OPTARG="-$LONG_OPTION"
            else
                OPTARG="$LONG_OPTARG";
                if [[ $LONG_OPTIND -ne -1 ]]; then
                    [[ $OPTIND -le $Optnum ]] && OPTIND=$(( $OPTIND+1 ))
                    shift $OPTIND
                    OPTIND=1
                fi
            fi
        fi
    fi

    #== options follow by another option instead of argument ==#
    if [[ "x${OPTION}" != "x:" ]] && [[ "x${OPTION}" != "x?" ]] && [[ "${OPTARG}" = -* ]]; then
        OPTARG="$OPTION" OPTION=":"
    fi
    #== manage options ==#
getopts_get_optional_argument() {
  eval next_token=\${$OPTIND}
  if [[ -n $next_token && $next_token != -* ]]; then
    OPTIND=$((OPTIND + 1))
    OPTARG=$next_token
  else
    OPTARG=""
  fi
}
    case "$OPTION" in
        a ) flagOptMenu=0;flagOptAutorite=1;;

        r ) flagOptMenu=0;flagOptRevoke=1;OptRevokeCert="${OPTARG}";;


        i ) flagOptMenu=0;flagOptIntermediate=1
            OptIntermediatePath="${OPTARG}";;

        s ) flagOptMenu=0;
        getopts_get_optional_argument $@
        OptCN="${OPTARG}";
        flagOptServeur=1;;

        c ) flagOptMenu=0;
        getopts_get_optional_argument $@
        OptCN=${OPTARG}
        echo $OptCN
        flagOptClient=1;;

        m)  flagOptMenu=0;flagOptMontre=1
            OptCert="${OPTARG}";;

        h ) usagefull
            exit 0;;

        j ) scriptinfo
            exit 0;;

        v ) flagOptVerbose=1
            set -x;;

        : ) echo "${SCRIPT_NAME}: -$OPTARG: option requires an argument"
            flagOptErr=1 ;;

        ? ) echo "${SCRIPT_NAME}: -$OPTARG: unknown option"
            flagOptErr=1 ;;
    esac
done
shift $((${OPTIND} - 1)) ## shift options

#============================
#  MAIN SCRIPT
#============================
if [ $flagOptMenu -eq 1 ];then
    usagefull
    exit 0
fi
if [ ! -f /etc/default/ssl ];then

    DoDefault
fi

. /etc/default/ssl

if [ "${flagOptAutorite}" = "1" ];then
    CreerAutorite
fi

if [ "${flagOptClient}" = "1" ];then
    [[ -r $KEYFILE ]] && CreerCertificat
    [[ -r $KEYFILE ]] || echo $KEYFILE not readable 1>&2 && exit 1;
fi
if [ "${flagOptServeur}" = "1" ];then
    [[ -r $KEYFILE ]] && CreerCertificat
    [[ -r $KEYFILE ]] || echo $KEYFILE not readable 1>&2 && exit 1;
fi
if [ "${flagOptRevoke}" = "1" ];then
    [[ -r $KEYFILE ]] && RevokeCertificat
    [[ -r $KEYFILE ]] || echo $KEYFILE not readable 1>&2 && exit 1;
fi
if [ "${flagOptMontre}" = "1" ];then
    openssl x509 -in ${dir}/certs/${OptCert}.pem -noout -text
fi

